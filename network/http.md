# HTTP

## HTTP의 4단계 처리 단계

1. Connection: 클라이언트와 서버가 TCP 커넥션을 형성 (3-way handshake)
2. Request: 클라이언트가 서버에 특정 URL의 자원을 요청한다는 메시지를 전송
3. Response: 서버가 클라이언트의 요청에 맏는 응답 메시지를 전송
4. Close: 클라이언트나 서버 둘 중 누군가가 연결을 끊음

## 🌱 HTTP의 발전 과정

### HTTP/1.1

한 쌍의 요청과 응답에 대해 하나의 연결을 사용합니다. 

<img width="612" alt="image" src="https://user-images.githubusercontent.com/45311765/203532672-9beb3367-d214-4ca3-afd6-e7a2c6f650cc.png">

HTTP/1.1의 청크(chunk) 전송을 이용하면 데이터 스트리밍이 가능합니다. 

### [SPDY](https://ko.wikipedia.org/wiki/SPDY)

**웹 콘텐츠를 전송할 목적**으로 구글이 개발한 비표준 개방형 네트워크 프로토콜입니다. SPDY는 웹 페이지의 로딩 시간을 줄이기 위한 목적으로 설계되었습니다. 이를 위해 SPDY 클라이언트는 하나의 소켓 연결을 통해 페이지를 구성하는 여러개의 하위 요소를 한꺼번에 전송받을 수 있도록 만들어졌습니다. 또한 gzip 또는 deflate 알고리즘을 활용해 헤더를 압축해서 전송합니다. SPDY 서버는 클라이언트의 요청을 기다리지 않고, 페이지의 내용이 변경되었음을 클라이언트에게 알리거나 새 변경 내용을 직접 전송할 수 있습니다. SPDY는 반드시 SSL 또는 TLS로 암호화된 프로토콜을 사용해야 합니다. 

HTTP는 HTTP를 대체하는 프로토콜이 아니라 HTTP가 전송 계층을 통해 전송되는 방식을 재정의하는 프로토콜입니다. SPDY는 HTTP 2.0의 초안이 되었습니다. 

### TLS(Transmission Control Protocol)

일반적인 TCP를 사용하는 경우 클라이언트와 서버는 1 RTT인 TCP 3-way 핸드셰이킹을 수행한 뒤 즉시 어플리케이션 데이터를 전송합니다. 이때 TLS는 TCP에서 작동하기 때문에 먼저 TCP 핸드셰이킹을 수행하고 암호화 파라미터를 협상하기 위해 추가적으로 TLS 핸드셰이킹을 수행합니다. 따라서 추가로 2 RTT를 더 소비하게 돼 네트워크 속도가 느려지게 됩니다. 특히 모바일 환경에서는 연결이 끊기거나 다시 연결되는 경우가 매우 많기 때문에 상황이 악화될 수 있습니다. 

> [RTT(Round Trip Time, 왕복 시간)](https://en.wikipedia.org/wiki/Round-trip_delay)는 패킷이 목적지에 도달하고 나서 해당 패킷에 대한 응답이 출발지로 다시 돌아오기까지의 시간, 즉 `패킷 왕복 시간`을 의미합니다. 네트워크 성능을 측정할 때, RTT는 네트워크 연결의 속도와 안정성을 진단하는 지표로 사용됩니다. 

위의 내용은 TLS 1.2에 대한 내용이었고, TLS 1.3에서는 더 나은 핸드셰이킹 메커니즘을 도입해 협상 과정을 1 RTT로 줄였습니다. 일부 설정에서는 0 RTT 핸드셰이킹을 제공해 협상 중에 어플리케이션 데이터를 보낼 수도 있다고 합니다. 

이렇게 TLS 1.3을 사용하면 속도 문제가 개선되지만 TLS 1.2를 사용하면서도 현상 과정을 1 RTT로 줄일수는 없을까요? 클라이언트가 서버에 다시 연결을 시도할 때 첫번째 연결에서 사용한 암호화 파라미터를 재사용한다면, 클라이언트와 서버가 암호화 파라미터와 같은 세션 정보를 기억하고 재사용하기로 동의한다면, 협상 RTT를 줄일 수 있을 것입니다. 이를 `세션 재개(session resumption)`이라고 합니다. TLS 1.2의 세션 ID와 TLS 익스텐션의 세션 티켓을 활용해 구현할 수 있습니다. 

`세션 ID`  
세션 ID를 확안해 이전 요청이 있었는지 확인하고 암호화 파라미터를 재사용할 수 있습니다. 이때 세션 ID를 저장해야하는데, 모든 서버 인스턴스가 공유하는 세션 스토리지(Redis 등)를 사용해야 합니다. 👉 스테이트풀(stateful)

`세션 티켓`  
세션 티켓은 세션 ID와 다르게 스테이트리스(stateless) 세션 재개입니다. 세션을 서버에 저장하지 않고 티켓이라고 부르는 세션 데이터를 생성해서 이 티켓을 클라이언트로 리턴합니다. 클라이언트가 서버에 다시 연결을 시도할 때 가지고 있던 티켓을 함께 전송합니다. 서버는 가지고 있는 비밀키로 티켓을 복호화해서 세션 정보를 확인합니다. 만약 티켓이 만료되면 전체 TLS 핸드셰이킹을 다시 수행해야합니다. 

### HTTP/2

HTTP/2에서는 SPDY와 유사하게 헤더 압축을 지원하며 더 효율적인 HPACK 알고리즘을 활용합니다. HTTP/2에서는 메시지 본문이 여러 데이터 프레임으로 나뉘어 각각 다른 스트림으로 전송됩니다.  

HTTP/2에서는 하나의 연결을 여러 스트림으로 다중화하기 때문에 쉽게 스트리밍을 지원할 수 있습니다. 

> `네트워크 추상화 계층(Network Abstract Layer)`을 도입해 프로토콜을 직접 고르는 것이 아니라 어떤 프로토콜을 사용할지 어떤 프로토콜로 처리할지를 자율적으로 설정할 수 있습니다. 이렇게 어떤 프로토콜로 처리할지에 대한 클라이언트 설정은 `Connection Info`를 사용해 설정할 수 있습니다. LINE에서는 Connection Info를 이용해 클라이언트의 국가별로, 사용 네트워크(WIFI, 모바일 등) 별로 설정을 다르게 제어하고 있다고 합니다. 

### QUIC

## 참고 자료

- [LINT: HTTP/2와 TLS를 통한 네트워크 현대화 by LINE 이벽산](https://engineering.linecorp.com/ko/blog/LINT-newtork-modernization-http2-tls/)
